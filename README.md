# NetCoWEBServe

1.  实现了自旋锁类
2.  实现了时间类(基本单位是ms)
3.  实现了上下文类
4.  实现了内存池模板类
    实现细节：
            该类中有4个数据成员，分别是空闲链表指针、malloc链表指针(该链表将每次用malloc申请的内存块连接起来)
            使用malloc的次数以及要申请的内存块的大小。
            空闲链表指针和malloc链表指针的类型为一个union类型的结构体，该结构体有一个指向下一块内存的指针
            和一个char类型的data。
            当向内存池索要内存空间时先检查空闲链表指针是否为空，如果为空，则有两种情况
            第一种情况是内存池对象刚创建，还未向系统申请内存当做备用
            第二种情况是已没有空闲内存块可供使用。
            这时就需要向操作系统申请大块内存。
            每一次向系统申请的大块内存的大小都不同，内存大小随着申请次数的增加而增加，具体为
            要申请的内存块大小*(基数+使用malloc的次数) + union类型的结构体的大小。
            之后将申请到的大块内存的首地址连接到malloc链表中。
            再将申请到的内存的首地址 + union类型的结构体的大小得到真正用的内存块的首地址
            然后按照要申请的内存块的大小将得到的大块内存进行分割并保存到空闲链表中。
            之后返回空闲链表的首地址并将空闲链表指针指向空闲链表的next。

            定义成模板是为了代码复用
5.  实现了工作池模板类
    实现细节：
            该类是实际使用的类，封装了内存池模板类
            该类在申请和释放内存时，根据传入的类型的不同调用不同的申请和释放内存的函数
            主要区别在于传入的类型的构造函数是否是平凡的
            如果是平凡的，则直接调用在内存池中获取内存块的函数
            如果是平凡的，则先调用在内存池中获取内存块的函数，然后在获取的内存
            块上执行传入类型的构造函数
            在删除构造的对象时，如果是平凡的构造函数，则直接调用内存池的释放函数
            将相应的内存块挂载到空闲链表上
            如果是非平凡的构造函数，那么闲调用对象的析构函数，再将相应的内存块
            挂载到空闲链表上

            定义成模板是为了代码复用
6.  实现了epoll类
    实现细节：
            将epoll_event结构体中的data结构体的ptr成员赋值为协程类的指针，这样在epoll返回就绪事件的时候就可以得到该事件对应的协程对象指针，
            从而恢复该协程运行。
            

7.  实现了协程类
    实现细节：
            协程类中有一个静态函数coWrapFunc(Processor* processor)，该静态函数有一个参数，参数是处理器类的指针。
            该静态函数总共调用了两个方法，一个是获取当前正在执行的协程方法，还有一个方法是回收该协程方法。
            在该静态函数中调用了处理器类的获取当前正在执行的协程方法得到正在运行的协程
            之后该协程开始执行。
            当该协程执行完了后接着调用回收协程的方法，将该协程放入移除队列中。
            处理器类中的loop循环会检查移除队列，如果移除队列不为空的话，先从协程的执行队列中将该协程移除
            之后调用工作池的delete_obj方法将该协程占用的空间回收掉
            即每个协程执行的函数是coWrapFunc函数。

8.  实现了定时器类
    实现细节：
            通过timerfd_create函数来创建一个定时器描述符，并将其添加到epoll中
            当定时器的时间到达时，epoll会返回定时器描述符
            timeFd_ = ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);
            其中，CLOCK_MONOTONIC表示一个不可设置的单调递增时钟，且不测量系统挂起时间
            该类使用时间类来实现定时时间的设置。
            
9.  实现了处理器类
            处理器类管理协程的生存期。
            该类中有一个waitEvent方法，作用是将fd的等待事件添加到epoll中，并主动放弃CPU。该方法是对三个方法的封装。
            这三个方法分别是epoll类中的添加事件方法(addEV()),处理器类的yield()方法，以及epoll类中的移除事件方法，当为某个文件描述符
            添加等待事件时，意味着该文件描述符对应的协程需要等待，此时应该主动放弃CPU，保存当前协程的上下文环境并切换协程。当等待的事件发生时，
            再恢复该协程的运行。

            该类中含有一个mainCTx_数据成员，其类型是Context，现在通过程序流程来查看其作用
            当运行一个co_go函数时，会先执行getSCheduler()函数来获取调度器，该函数是个静态函数，用来初始化一个静态调度器对象pScher_
            如果pScher_是空，即nullptr，该函数会对其进行初始化，并调用startScheduler函数来创建处理器对象，在调用处理器构造函数时会对mainCTX_进行初始化
            即将当前的上下文环境保存到mainCTX_中。也就是说现在的mainCTX_保存的上下文环境是刚建立处理器类对象时的上下文环境，之后startScheduler开始执行处理器类的loop函数
            在该loop函数中对epoll对象和定时器对象进行初始化，并创建一个线程，在该线程中执行while循环，while循环中按照如下顺序执行协程：
            先执行定时时间到来的协程，再执行刚到来的协程，最后执行恢复活跃的协程。
            计算机有几个核就创建几个线程，之后拿到了调度器对象，该调度器对象再运行createNewCo函数来运行一个新的协程
            createNewCo函数中实际上使用了处理器选择器对象来选择一个处理器来执行该协程。createNewCo函数会调用选择的处理器对象的goNewCo函数，goNewCo函数会
            从工作池中创建一个协程对象来执行该协程函数，刚创建时该协程的对象是CO_READY状态。
            co_go函数传入的协程函数是创建套接字并绑定、监听，之后在while循环中调用accept函数来接收新的连接。那么刚才创建的协程对象就会执行该函数，由于该协程是刚到来的
            协程，还未正式开始运行，之后在处理器对象的loop方法中就会使用resume方法来运行这个刚刚创建的协程，在resume方法中，会将要运行的协程赋值给处理器对象中正在运行的协程数据成员
            之后执行协程对象的resume方法，由于协程对象还处在CO_READY状态，所以会将其设置为CO_RUNNING状态，之后会执行makeContext方法来设置协程运行时的运行函数并指定函数运行完时需要
            执行的上下文环境，之后执行swapToMe(context*)方法，该方法中会调用swapcontext(pOldCtx->getUCtx(), &ctx_)的方法来将当前的上下文环境保存到pOldCtx->getUCtx()中，由于这个方法
            传入的参数是mainCTX_，所以会将当前的上下文环境保存到mainCTX_中，并开始执行刚刚创建的那个协程函数。
            该协程函数会执行accept方法，该accept函数是对网络编程中accept函数的高层封装
            该函数是非阻塞的，如果没有新的连接到来，它会返回一个不可用的socket对象，当accept函数判断该socket对象不可用时就知道现在并没有新的连接到来，然后将该文件描述符的EPOLLIN事件加入epoll中
            等待新连接的到来。上树的过程是通过调用waitEvent函数来实现的，该函数不仅将关心的事件加入epoll中，同时在加入epoll成功以后会调用yield函数来放弃当前CPU的执行权
            处理器类的yield函数会调用当前协程对象的yield函数，但是协程对象的yield函数只是将协程的状态设置成了等待状态，并没有做其他操作，而处理器对象的yield方法在调用了完了协程对象的yield方法后会
            会执行mainCtx_.swapToMe(pCurCoroutine_->getCtx());即切换协程
            在上下文对象的swapToMe方法中调用swapcontext(pOldCtx->getUCtx(), &ctx_)的方法来将当前的上下文环境保存到pOldCtx->getUCtx()中，并切换到mainCtx_所在的上下文环境。
            在前面中讲到，mainCtx的上下环境还在resume方法中，所以会继续执行resume方法，resume方法退出后会在loop方法中继续执行

10. 实现了调度器类
